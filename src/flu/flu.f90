!>
!! @file   flu.f90
!! @author Pawel Biernat <pawel.biernat@gmail.com>
!! @date   Tue Feb 21 21:49:43 2012
!!
!! @brief Contains wrappers to C API of Lua 5.2.
!!
!! The wrappers are mostly one to one as expected, with few
!! exceptions. All exceptions are described in comments, and consist
!! mostly of changing return values from 0 and 1 to .false. and
!! .true. respectively.
!!
!! Besides wrappers to some Lua functions, there are also several
!! implementations of macros defined by lua.h, which are also
!! implemented in a way consistent with lua documentation.
!!
!!
!!
module flu_module
  use iso_c_binding
  use c_lua_module
  use c_helper_module
  use logger_module
  use constants_module

#ifdef luajit
#define lua51
#endif

  !> lua constants, copied from lua.h
  integer(c_int), parameter ::                          &
       C_LUA_MULTRET = -1,                              &
       C_LUA_MAXSTACK = 1000000,                        &
       C_LUA_FIRSTPSEUDOINDEX = -C_LUA_MAXSTACK - 1000, &
       C_LUA_GLOBALSINDEX = -10002

#ifdef luajit
  integer(c_int), parameter :: C_LUA_REGISTRYINDEX = -10000
#else
  integer(c_int), parameter :: C_LUA_REGISTRYINDEX = C_LUA_FIRSTPSEUDOINDEX
#endif

  !> fortran version of the above parameters
  integer, parameter :: &
       LUA_MULTRET           = int(C_LUA_MULTRET),           &
       LUA_MAXSTACK          = int(C_LUA_MAXSTACK),          &
       LUA_FIRSTPSEUDOINDEX  = int(C_LUA_FIRSTPSEUDOINDEX),  &
       LUA_REGISTRYINDEX     = int(C_LUA_REGISTRYINDEX),     &
       LUA_GLOBALSINDEX      = int(C_LUA_GLOBALSINDEX)

  !> lua types, copied from lua.h
  !> @todo [0] change C_LUA_ prefix to LUA_
  integer, parameter ::&
       C_LUA_TNONE          =(-1),&
       C_LUA_TNIL           =0,&
       C_LUA_TBOOLEAN       =1,&
       C_LUA_TLIGHTUSERDATA =2,&
       C_LUA_TNUMBER        =3,&
       C_LUA_TSTRING        =4,&
       C_LUA_TTABLE         =5,&
       C_LUA_TFUNCTION      =6,&
       C_LUA_TUSERDATA      =7,&
       C_LUA_TTHREAD        =8

  !> return codes of lua_load and others
  integer, parameter ::&
       LUA_OK        =0,& !< no errors
       LUA_YIELD     =1,&
       LUA_ERRRUN    =2,&
       LUA_ERRSYNTAX =3,& !<syntax error during precompilation;
       LUA_ERRMEM    =4,& !<memory allocation error;
       LUA_ERRGCMM   =5,& !<error while running a __gc
                          !metamethod. (This error has no relation
                          !with the chunk being loaded. It is
                          !generated by the garbage collector.)
       LUA_ERRERR    =6

  !> a type used as a handle for userdata. it stores a pointer to the
  !> real data
  type, public :: lua_userdata_ptr
     type(c_ptr) :: ptr
  end type lua_userdata_ptr

  !> assumed size of userdata, @todo check if 32 bytes is enough
  integer, parameter :: C_LUA_USERDATA_PTR_SIZE = 100

  abstract interface
     !> abstract interface to the type of lua_CFunction
     integer(c_int) function c_lua_cfunction(l) bind(c)
       use iso_c_binding, only: c_int, c_ptr
       type(c_ptr), value :: l
     end function c_lua_cfunction

  end interface

  public :: c_lua_cfunction

  !> this class takes care of the lua VM
  type, public, extends(named) :: flu
     type(c_ptr) :: lstate = c_null_ptr
   ! contains
     ! procedure :: init
     ! procedure :: free
     ! procedure :: push_by_key
     ! procedure :: get_recursively
     ! procedure :: load_file
     ! procedure :: array_to_key
     ! procedure :: get_len
     ! procedure, private :: get_character
     ! procedure, private :: get_real
     ! procedure, private :: get_real_array
     ! generic :: get => get_real, get_character, get_real_array
  end type flu

contains

  !> Creates new luaVM and checks if real type is compatible with this
  !! lua build
  function luaL_newstate() result(l)
    type(flu) :: l
    character(len=2) :: k
    real :: r = 123.
    l%lstate = c_luaL_newstate()
    l%name = "luavm"

    call lua_pushnumber(l,r)
    ! check if the pushed number is unchanged after retrieving it from
    ! lua
    if ( r /= luaL_checknumber(l,-1) ) then
       write(k,'(i2)') kind(r)
       call l%log(FPDE_LOG_ERROR, "Lua number type is incompatible with real("//k//")")
       return
    end if

  end function luaL_newstate


  subroutine lua_close(l)
    type(flu) :: l
    call c_lua_close(l%lstate)
  end subroutine lua_close


  function luaL_loadstring(l, str)
    type(flu) :: l
    integer :: luaL_loadstring
    character(len=*) :: str
    luaL_loadstring = c_luaL_loadstring(l%lstate,str//c_null_char)
  end function luaL_loadstring

#ifdef lua52
  function lua_pcallk(l, nargs, nresults, errfunc, ctx, k)
    integer :: lua_pcallk
    type(flu) :: l
    type(c_ptr) :: k
    integer :: nargs, nresults, errfunc, ctx

    lua_pcallk = c_lua_pcallk(&
         l%lstate, &
         int(nargs,c_int), &
         int(nresults,c_int),&
         int(errfunc,c_int),&
         int(ctx,c_int),&
         k)

   end function lua_pcallk
#endif

  subroutine lua_getfield(l,index, name)
    type(flu) :: l
    integer :: index
    character(len=*) :: name
    call c_lua_getfield(l%lstate,int(index,c_int),trim(name)//c_null_char)
  end subroutine lua_getfield


  subroutine lua_setfield(l, index, name)
    type(flu) :: l
    integer :: index
    character(len=*) :: name
    call c_lua_setfield(l%lstate,int(index,c_int),name//c_null_char)
  end subroutine lua_setfield


  subroutine lua_getglobal(l, name)
    type(flu) :: l
    character(len=*) :: name
#ifdef lua51
    call c_lua_getfield(l%lstate, C_LUA_GLOBALSINDEX, name//c_null_char)
#endif
#ifdef lua52
    call c_lua_getglobal(l%lstate, trim(name)//c_null_char)
#endif
  end subroutine lua_getglobal


  subroutine lua_setglobal(l, name)
    type(flu) :: l
    character(len=*) :: name
#ifdef lua51
    call c_lua_setfield(l%lstate, C_LUA_GLOBALSINDEX, name//c_null_char)
#endif
#ifdef lua52
    call c_lua_setglobal(l%lstate, trim(name)//c_null_char)
#endif
  end subroutine lua_setglobal


  subroutine lua_getlocal(l, name)
    type(flu) :: l
    character(len=*) :: name
    call c_lua_getlocal(l%lstate, name//c_null_char)
  end subroutine lua_getlocal


  subroutine lua_setlocal(l, name)
    type(flu) :: l
    character(len=*) :: name
    call c_lua_setlocal(l%lstate, name//c_null_char)
  end subroutine lua_setlocal


  function lua_setfenv(l,index)
    type(flu) :: l
    integer :: index, lua_setfenv
    lua_setfenv = c_lua_setfenv(l%lstate, int(index,c_int))
  end function lua_setfenv

  subroutine lua_createtable(l,narr,nrec)
    type(flu) :: l
    integer :: narr, nrec
    call c_lua_createtable(l%lstate,&
         int(narr,c_int),int(nrec,c_int))
  end subroutine lua_createtable

  subroutine lua_newtable(l)
    type(flu) :: l
    call lua_createtable(l,0,0)
  end subroutine lua_newtable


  ! lua_tolstring is missing, but it was used only in lua_tostring
  ! function, which is implemented below instead of lua_tolstring

  !> calls c_lua_tostring and saves the returned string to str
  !!
  !! @param str returned string
  !!
  subroutine lua_tostring(l, index, str)
    type(flu) :: l
    character(len=*), intent(out) :: str
    integer :: index
    integer(c_size_t) :: len
    type(c_ptr) :: ptr

    ptr = c_lua_tolstring(&
         l%lstate,&
         int(index,c_int),&
         len)

    call c_ptr_to_str(ptr, str, int(len,kind(1)))
  end subroutine lua_tostring


  subroutine lua_settop(l,stackIdx)
    type(flu) :: l
    integer :: stackIdx
    call c_lua_settop(l%lstate, int(stackIdx,c_int))
  end subroutine lua_settop


  function lua_isstring(l, index)
    type(flu) :: l
    integer :: index
    logical :: lua_isstring

    if(c_lua_isstring(l%lstate, int(index,c_int)) == 1) then
       lua_isstring = .true.
    else
       lua_isstring = .false.
    end if
  end function lua_isstring


  function lua_type(l,index)
    type(flu) :: l
    integer :: index, lua_type
    lua_type = c_lua_type(l%lstate, int(index,c_int))
  end function lua_type


  !> Tries to load a file and log any lua errors
  !!
  !! @param filename should be already trimmed
  !!
  !! @return .true. if file loads correctly, .false. otherwise
  !!
  function luaL_loadfile(l, filename)
    logical :: luaL_loadfile
    type(flu) :: l
    integer :: retval
    character(len=*) :: filename
    character(len=1000) :: msg

#ifdef lua52
    retval = c_luaL_loadfilex_ptr(&
         l%lstate,&
         trim(filename)//c_null_char,&
         c_null_ptr)
#endif
#ifdef lua51
    retval = c_luaL_loadfile_ptr(&
         l%lstate,&
         trim(filename)//c_null_char)
#endif

    if( retval == LUA_OK ) then
       luaL_loadfile = .true.
       return
    else
       luaL_loadfile = .false.
       call lua_tostring(l,-1,msg)
       call l%log(FPDE_LOG_ERROR,"Unable to load file ["//filename//"]")
       call l%log(FPDE_LOG_ERROR,"Lua error:[" // trim(msg) // "]")
    end if
  end function luaL_loadfile


  subroutine lua_gettable(l,index)
    type(flu) :: l
    integer :: index
    call c_lua_gettable(l%lstate, int(index,c_int))
  end subroutine lua_gettable


  subroutine lua_rawget(l,index)
    type(flu) :: l
    integer :: index
    call c_lua_rawget(l%lstate, int(index,c_int))
  end subroutine lua_rawget


  subroutine lua_rawgeti(l,index,n)
    type(flu) :: l
    integer :: index, n
    call c_lua_rawgeti(l%lstate, int(index,c_int), int(n,c_int))
  end subroutine lua_rawgeti


  function luaL_ref(l, index)
    type(flu) :: l
    integer :: index
    integer :: luaL_ref
    luaL_ref = c_luaL_ref(l%lstate, int(index,c_int))
  end function luaL_ref


  function lua_rawlen(l,index)
    type(flu) :: l
    integer :: index
    integer :: lua_rawlen
#ifdef lua52
    lua_rawlen = c_lua_rawlen(l%lstate, int(index,c_int))
#endif
#ifdef lua51
    lua_rawlen = c_lua_objlen(l%lstate, int(index,c_int))
#endif
  end function lua_rawlen


  subroutine lua_settable(l, index)
    type(flu) :: l
    integer :: index
    call c_lua_settable(l%lstate,int(index,c_int))
  end subroutine lua_settable


  function lua_absindex(l, index)
    type(flu) :: l
    integer :: index
    integer :: lua_absindex
#ifdef lua52
    lua_absindex = c_lua_absindex(l%lstate,int(index,c_int))
#endif
#ifdef lua51
    if( index < 0 ) then
       lua_absindex = lua_gettop(l) + 1 + index
    else
       lua_absindex = index
    end if
#endif
  end function lua_absindex


  function lua_topointer(l,index)
    type(flu) :: l
    type(c_ptr) :: lua_topointer
    integer :: index
    lua_topointer = c_lua_topointer(l%lstate,int(index,c_int))
  end function lua_topointer


  function lua_toprocpointer(l,index)
    type(flu) :: l
    type(c_funptr) :: lua_toprocpointer
    integer :: index
    lua_toprocpointer = c_lua_toprocpointer(l%lstate,int(index,c_int))
  end function lua_toprocpointer


  subroutine lua_pushinteger(l,i)
    type(flu) :: l
    integer :: i
    call c_lua_pushinteger(l%lstate, int(i,c_int))
  end subroutine lua_pushinteger


  subroutine lua_pushboolean(l,i)
    type(flu) :: l
    logical :: i
    if( i ) then
       call c_lua_pushboolean(l%lstate, int(1,c_int))
    else
       call c_lua_pushboolean(l%lstate, int(0,c_int))
    end if
  end subroutine lua_pushboolean


  subroutine lua_pushnil(l)
    type(flu) :: l
    call c_lua_pushnil(l%lstate)
  end subroutine lua_pushnil


  subroutine lua_pushnumber(l,val)
    type(flu) :: l
    real :: val
    call c_lua_pushnumber(l%lstate, val)
  end subroutine lua_pushnumber


  function lua_tointeger(l, idx)
    type(flu) :: l
    integer :: idx, lua_tointeger
#ifdef lua52
    lua_tointeger = c_lua_tointegerx(l%lstate, int(idx,c_int),c_null_ptr)
#endif
#ifdef lua51
    lua_tointeger = c_lua_tointeger(l%lstate, int(idx,c_int))
#endif
  end function lua_tointeger


  function lua_toboolean(l, idx)
    type(flu) :: l
    integer :: idx
    logical :: lua_toboolean

    if( c_lua_toboolean(l%lstate, int(idx,c_int)) == 1 ) then
       lua_toboolean = .true.
    else
       lua_toboolean = .false.
    end if

  end function lua_toboolean


  function lua_tonumber(l, idx)
    type(flu) :: l
    integer :: idx
    real(8) :: lua_tonumber
#ifdef lua52
    lua_tonumber = c_lua_tonumberx(l%lstate, int(idx,c_int),c_null_ptr)
#endif
#ifdef lua51
    lua_tonumber = c_lua_tonumber(l%lstate, int(idx,c_int))
#endif
  end function lua_tonumber


  !> Corresponds to lua_isnil macro
  !!
  !! @param idx index of element to be checked
  !!
  !! @return .true. if element is nil, .false. otherwise
  !!
  function lua_isnil(l,idx)
    type(flu) :: l
    integer :: idx
    logical :: lua_isnil

    if( lua_type(l, idx) == C_LUA_TNIL ) then
       lua_isnil = .true.
    else
       lua_isnil = .false.
    end if
  end function lua_isnil


  subroutine lua_pushstring(l, str)
    type(flu) :: l
    character(len=*) :: str
    call c_lua_pushstring(l%lstate, trim(str)//c_null_char)
  end subroutine lua_pushstring


  function lua_gettop(l)
    type(flu) :: l
    integer :: lua_gettop
    lua_gettop = c_lua_gettop(l%lstate)
  end function lua_gettop


  subroutine lua_replace(l,index)
    type(flu) :: l
    integer :: index
    call c_lua_replace(l%lstate,int(index,c_int))
  end subroutine lua_replace


  subroutine luaL_openlibs(l)
    type(flu) :: l
    call c_luaL_openlibs(l%lstate)
  end subroutine luaL_openlibs


  subroutine lua_pushcclosure(l, fun, n)
    type(flu) :: l
    integer :: n
    procedure(c_lua_cfunction) :: fun

    call c_lua_pushcclosure(&
         l%lstate,&
         c_funloc(fun),&
         int(n,c_int))
  end subroutine lua_pushcclosure


  !> @param cptr has to be type(c_ptr) instead of e.g. class(*)
  !! because of possible rank mismatch when passing a fortran array
  subroutine lua_pushlightuserdata(l, cptr)
    type(flu) :: l
    type(c_ptr) :: cptr
    call c_lua_pushlightuserdata(l%lstate, cptr)
  end subroutine lua_pushlightuserdata


  function lua_newuserdata(l, size)
    type(flu) :: l
    integer :: size
    type(c_ptr) :: lua_newuserdata
    lua_newuserdata = c_lua_newuserdata(&
         l%lstate,&
         int(size,c_size_t))
  end function lua_newuserdata


  subroutine lua_setmetatable(l, index)
    type(flu) :: l
    integer :: index
    call c_lua_setmetatable(l%lstate, int(index,c_int))
  end subroutine lua_setmetatable


  subroutine lua_getmetatable(l, index)
    type(flu) :: l
    integer :: index
    call c_lua_getmetatable(l%lstate, int(index, c_int))
  end subroutine lua_getmetatable


  function luaL_newmetatable(l, name)
    type(flu) :: l
    character(len=*) :: name
    logical luaL_newmetatable
    if( c_luaL_newmetatable(l%lstate, trim(name)//c_null_char) == 0 ) then
       luaL_newmetatable = .false.
    else
       luaL_newmetatable = .true.
    end if
  end function luaL_newmetatable


  function luaL_checknumber(l, index)
    type(flu) :: l
    integer :: index
    real :: luaL_checknumber
    luaL_checknumber = c_luaL_checknumber(&
         l%lstate, int(index, c_int))
  end function luaL_checknumber


  function luaL_checkinteger(l, index)
    type(flu) :: l
    integer :: index
    integer :: luaL_checkinteger
    luaL_checkinteger = c_luaL_checkinteger(&
         l%lstate, int(index, c_int))
  end function luaL_checkinteger


  function luaL_checkudata(l, index, name)
    type(flu) :: l
    integer :: index
    character(len=*) :: name
    type(c_ptr) :: luaL_checkudata
    luaL_checkudata = c_luaL_checkudata(&
         l%lstate,&
         int(index, c_int),&
         trim(name)//c_null_char)
  end function luaL_checkudata


  subroutine lua_pop(l, n) bind(C,name="lua_pop")
    type(flu) :: l
    integer :: n
    call lua_settop(l, -n-1)
  end subroutine lua_pop


  !> @return .true. if no problems, .false. otherwise
  function luaL_dofile(l, filename)
    logical :: luaL_dofile
    type(flu) :: l
    integer :: pcall
    character(len=*) :: filename

    luaL_dofile = .false.

    if( luaL_loadfile(l,trim(filename)) ) then
       pcall = lua_pcall(l,0,LUA_MULTRET,0)
       if( pcall == LUA_OK ) then
          luaL_dofile = .true.
          return
       end if
    end if

  end function luaL_dofile


  !> @return .true. if no problems, .false. otherwise
  function luaL_dostring(l, str)
    logical :: luaL_dostring
    type(flu) :: l
    integer :: pcall
    character(len=*) :: str

    luaL_dostring = .false.

    if( luaL_loadstring(l,trim(str)) == LUA_OK ) then
       pcall = lua_pcall(l,0,LUA_MULTRET,0)
       if( pcall == LUA_OK ) then
          luaL_dostring = .true.
          return
       end if
    end if

  end function luaL_dostring


  function lua_pcall(l,n,r,f)
    type(flu) :: l
    integer :: lua_pcall
    integer :: n, r, f

    character(len=1000) :: msg

#ifdef lua52
    lua_pcall = c_lua_pcallk(l%lstate,&
         int(n,c_int),&
         int(r,c_int),&
         int(f,c_int),&
         int(0,c_int),&
         c_null_ptr)
#endif
#ifdef lua51
    lua_pcall = c_lua_pcall(l%lstate,&
         int(n,c_int),&
         int(r,c_int),&
         int(f,c_int))
#endif

    if(lua_pcall /= LUA_OK) then
       call lua_tostring(l,-1,msg)
       call l%log(FPDE_LOG_ERROR,"Unable to call lua function")
       call l%log(FPDE_LOG_ERROR,"Lua error:[" // trim(msg) // "]")
    end if

  end function lua_pcall

  function lua_next(l,index)
    type(flu) :: l
    integer :: index
    integer :: lua_next
    lua_next = c_lua_next(l%lstate, int(index,c_int))
  end function lua_next


! !!!!!!!! Some high level lua calls

!   recursive function get_recursively(f, desc) result(r)
!     class(flu) :: f
!     character(len=*), intent(in) :: desc(:)
!     type(c_ptr) :: L
!     integer :: r
!     r = 0

!     L = f%lstate

!     call lua_pushstring(L,trim(desc(1))//c_null_char)
!     ! because we assume table is already on the top of the stack
!     ! index is -2
!     call lua_gettable(L,-2)
!     if( size(desc) > 1 ) then
!        if( lua_type(L,-1) == LUA_TTABLE ) then
!           r = get_recursively(f, desc(2:))
!        else if( lua_type(L,-1) == LUA_TNIL ) then
!           r = 1
!           call f%log( FPDE_LOG_ERROR, desc(1) // " is nil" )
!           return
!        else
!           r = 1
!           call f%log( FPDE_LOG_ERROR, desc(1) // " is not a table" )
!           return
!        end if
!     end if
!   end function get_recursively


!   !> pushes the value of the key f to the top of the stack
!   function push_by_key(f,id) result(r)
!     class(flu) :: f
!     character(len=*), intent(in) :: id(:)
!     integer :: t, r
!     type(c_ptr) :: L

!     r = 0
!     L = f%lstate

!     ! bring the root of the table to the stack
!     call lua_getglobal(L,trim(id(1))//c_null_char)
!     t = lua_type(L,-1)
!     ! call lua_tostring(L,-1,str)

!     if( size(id) > 1 ) then
!        if( t == LUA_TTABLE ) then
!           r = get_recursively(f,id(2:))
!        else
!           r = 1
!           call f%log( FPDE_LOG_ERROR, &
!                id(1) // " is not a table" )
!           return
!        end if
!     end if

!     ! one way or another we should end up with a string or table
!     if( (t /= LUA_TSTRING ) &
!          .and. (t /= LUA_TTABLE)&
!          .and. (t /= LUA_TNUMBER) ) then
!        r = 1
!        call f%log(FPDE_LOG_ERROR, &
!             "type of " // trim(f%array_to_key(id)) // " is not supported")
!        return
!     end if

!   end function push_by_key


!   ! initializes lua vm
!   subroutine init(f)
!     class(flu) :: f
!     f%lstate = luaL_newstate()
!     f%name = "flu"

!     if( c_associated( f%lstate ) ) then
!        call luaL_openlibs( f%lstate )
!        call f%log(FPDE_LOG_INFO, "Lua VM started")
!     else
!        call f%log(FPDE_LOG_ERROR, "unable to run Lua VM")
!     end if

!   end subroutine init


!   function get_character(f, id, out) result(r)
!     class(flu) :: f
!     character(len=*), intent(in) :: id(:)
!     character(len=*), intent(out) :: out
!     ! @bug: fixed length string
!     integer :: r

!     ! get the variable to the top of the stack
!     if( f%push_by_key(id) /= 0 ) then
!        r = 1
!        return
!     else if( lua_type(f%lstate,-1) == LUA_TSTRING ) then
!        call lua_tostring(f%lstate,-1,out)
!        r = 0
!        return
!     else
!        r = 1
!        call f%log(FPDE_LOG_ERROR,&
!             f%array_to_key(id)//" is not a string")
!        return
!     end if

!   end function get_character


!   function get_real(f, id, out) result(r)
!     class(flu) :: f
!     character(len=*), intent(in) :: id(:)
!     real, intent(out) :: out
!     ! @bug: fixed length string
!     character(len=100) :: str
!     integer :: r

!     ! get the variable to the top of the stack
!     if( f%push_by_key(id) /= 0 ) then
!        r = 1
!        return
!     else if( lua_type(f%lstate,-1) == LUA_TNUMBER ) then
!        call lua_tostring(f%lstate,-1,str)
!        read(str, *) out
!        r = 0
!        return
!     else
!        r = 1
!        call f%log(FPDE_LOG_ERROR,&
!             f%array_to_key(id)//" is not a number")
!        return
!     end if
!   end function get_real

!   ! writes length of the table designated by id to out
!   function get_len(f, id, out) result(r)
!     class(flu) :: f
!     character(len=*), intent(in) :: id(:)
!     integer, intent(out) :: out
!     ! @bug: fixed length string
!     character(len=100) :: str
!     integer :: r, i = 0, n = 0
!     type(c_ptr) :: L

!     L = f%lstate
!     ! get the variable to the top of the stack
!     if( f%push_by_key(id) /= 0 ) then
!        r = 1
!        return
!     else if( lua_type(L,-1) == LUA_TTABLE ) then
!        r = 0
!        ! determine the length of the array
!        out = lua_len(L, -1)
!     else
!        r = 1
!        call f%log(FPDE_LOG_WARNING,&
!             f%array_to_key(id)//" is not a table")
!        return
!     end if
!   end function get_len


!   function get_real_array(f, id, out) result(r)
!     class(flu) :: f
!     character(len=*), intent(in) :: id(:)
!     real, pointer, intent(out) :: out(:)
!     ! @bug: fixed length string
!     character(len=100) :: str
!     integer :: r, i = 0, n = 0
!     type(c_ptr) :: L

!     L = f%lstate
!     ! get the variable to the top of the stack
!     if( f%push_by_key(id) /= 0 ) then
!        r = 1
!        return
!     else if( lua_type(L,-1) == LUA_TTABLE ) then

!        ! determine the length of the array
!        n = lua_len(L, -1)
!        ! pop the length
!        call lua_pop(L,1)

!        ! read all the numbers
!        do i = 1, n
!           ! call lua_pushstring(L,trim(itoa(i))//c_null_char)
!           call lua_pushinteger(L,i)
!           call lua_gettable(L,-2)
!           if(lua_type(L,-1) == LUA_TNUMBER ) then
!              call lua_tostring(L,-1,str)
!              read(str, *) out(i)
!              ! pop the result, so the table is back at index -1
!              call lua_pop(L,1)
!           else
!              ! error, one of the elements is not a number
!              r = 1
!              call f%log(FPDE_LOG_ERROR,&
!                   trim(f%array_to_key(id))//"["//trim(itoa(i))//"] is not a number")
!              return
!           end if
!        end do
!        r = 0
!        return
!     else
!        r = 1
!        call f%log(FPDE_LOG_ERROR,&
!             f%array_to_key(id)//" is not a number")
!        return
!     end if
!   end function get_real_array


!   ! turns array of the form ["a", "b", "c"] to "a.b.c"
!   function array_to_key(f,key) result(r)
!     class(flu) :: f
!     character(len=*) :: key(:)
!     character(len=size(key)*(len(key)+len("."))) :: r

!     r = join(key, ".")
!   end function array_to_key

!   ! @todo extract to some utils library
!   function join(key, space) result(r)
!     character(len=*) :: key(:)
!     character(len=*) :: space
!     character(len=size(key)*(len(key)+len(space))) :: r
!     integer :: i

!     r = key(1)

!     do i = 2, size(key)
!        ! if( len(trim(key(1))) == 0) continue
!        r = trim(r)//space//key(i)
!     end do

!   end function join

!   ! @todo extract to some utils library
!   function itoa(i) result(r)
!     integer, intent(in) :: i
!     ! possibly @bug, constant length character on output
!     character(len=100) :: r

!     write(r,'(i99)') i
!     r=trim(adjustl(r))

!   end function itoa


end module flu_module
