!>
!! @file   flu.f90
!! @author Pawel Biernat <pawel.biernat@gmail.com>
!! @date   Tue Feb 21 21:49:43 2012
!!
!! @brief
!!
!! @todo : separate low-level operations to flu_primitives
!! @todo : pop the stack after get_
!!
!!
!!
module flu_module
  use iso_c_binding !, only: c_ptr, c_null_ptr, c_null_char, c_char, c_int
  use c_lua_module
  use c_helper_module
  use logger_module


  !> lua constants
  integer, parameter :: &
       C_LUA_MULTRET = -1,&
       C_LUAI_MAXSTACK = 1000000,&
       C_LUAI_FIRSTPSEUDOINDEX = -C_LUAI_MAXSTACK - 1000,&
       C_LUA_REGISTRYINDEX = C_LUAI_FIRSTPSEUDOINDEX

  !> lua types
  integer, parameter ::&
       C_LUA_TNONE          =(-1),&
       C_LUA_TNIL           =0,&
       C_LUA_TBOOLEAN       =1,&
       C_LUA_TLIGHTUSERDATA =2,&
       C_LUA_TNUMBER        =3,&
       C_LUA_TSTRING        =4,&
       C_LUA_TTABLE         =5,&
       C_LUA_TFUNCTION      =6,&
       C_LUA_TUSERDATA      =7,&
       C_LUA_TTHREAD        =8

  !> return codes of lua_load and others
  integer, parameter ::&
       LUA_OK        =0,& !< no errors
       LUA_YIELD     =1,&
       LUA_ERRRUN    =2,&
       LUA_ERRSYNTAX =3,& !<syntax error during precompilation;
       LUA_ERRMEM    =4,& !<memory allocation error;
       LUA_ERRGCMM   =5,& !<error while running a __gc
                          !metamethod. (This error has no relation
                          !with the chunk being loaded. It is
                          !generated by the garbage collector.)
       LUA_ERRERR    =6

  !> a type used as a handle for userdata. it stores a pointer to the
  !> real data
  type, public :: c_lua_userdata_ptr
     type(c_ptr) :: ptr
  end type c_lua_userdata_ptr

  !> assumed size of userdata, @todo check if 32 bytes is enough
  integer(c_int), parameter :: C_LUA_USERDATA_PTR_SIZE = 100

  abstract interface
     !> abstract interface to the type of lua_CFunction
     integer(c_int) function c_lua_cfunction(l) bind(c)
       use iso_c_binding, only: c_int, c_ptr
       type(c_ptr), value :: l
     end function c_lua_cfunction

  end interface

  public :: c_lua_cfunction

  !> this class takes care of the lua VM
  type, public, extends(named) :: flu
     type(c_ptr) :: lstate = c_null_ptr
   ! contains
     ! procedure :: init
     ! procedure :: free
     ! procedure :: push_by_key
     ! procedure :: get_recursively
     ! procedure :: load_file
     ! procedure :: array_to_key
     ! procedure :: get_len
     ! procedure, private :: get_character
     ! procedure, private :: get_real
     ! procedure, private :: get_real_array
     ! generic :: get => get_real, get_character, get_real_array
  end type flu

contains

  !> Creates new luaVM and checks if real type is compatible with this
  !! lua build
  function luaL_newstate() result(l)
    type(flu) :: l
    character(len=2) :: k
    real :: r = 123.
    l%lstate = c_luaL_newstate()

    call lua_pushnumber(l,r)
    ! check if the pushed number is unchanged after retrieving it from
    ! lua
    if ( r /= luaL_checknumber(l,-1) ) then
       write(k,'(i2)') kind(r)
       call l%log(FPDE_LOG_ERROR, "Lua number type is incompatible with real("//k//")")
    end if
  end function luaL_newstate


  subroutine lua_close(l)
    type(flu) :: l
    call c_lua_close(l%lstate)
  end subroutine lua_close


  function luaL_loadstring(l, str)
    type(flu) :: l
    integer :: luaL_loadstring
    character(len=*) :: str
    luaL_loadstring = c_luaL_loadstring(l%lstate,str//c_null_char)
  end function luaL_loadstring


  function lua_pcallk(l, nargs, nresults, errfunc, ctx, k)
    integer :: lua_pcallk
    type(flu) :: l
    type(c_ptr) :: k
    integer :: nargs, nresults, errfunc, ctx
    lua_pcallk = c_lua_pcallk(&
         l%lstate, &
         int(nargs,c_int), &
         int(nresults,c_int),&
         int(errfunc,c_int),&
         int(ctx,c_int),&
         k)
  end function lua_pcallk


  subroutine lua_getfield(l,index, name)
    type(flu) :: l
    integer :: index
    character(len=*) :: name
    call c_lua_getfield(l%lstate,int(index,c_int),name//c_null_char)
  end subroutine lua_getfield


  subroutine lua_setfield(l, index, name)
    type(flu) :: l
    integer :: index
    character(len=*) :: name
    call c_lua_setfield(l%lstate,int(index,c_int),name//c_null_char)
  end subroutine lua_setfield


  subroutine lua_getglobal(l, name)
    type(flu) :: l
    character(len=*) :: name
    call c_lua_getglobal(l%lstate, name//c_null_char)
  end subroutine lua_getglobal


  subroutine lua_setglobal(l, name)
    type(flu) :: l
    character(len=*) :: name
    call c_lua_setglobal(l%lstate, name//c_null_char)
  end subroutine lua_setglobal


  subroutine lua_getlocal(l, name)
    type(flu) :: l
    character(len=*) :: name
    call c_lua_getlocal(l%lstate, name//c_null_char)
  end subroutine lua_getlocal


  subroutine lua_setlocal(l, name)
    type(flu) :: l
    character(len=*) :: name
    call c_lua_setlocal(l%lstate, name//c_null_char)
  end subroutine lua_setlocal

  ! lua_tolstring is missing, but it was used only in lua_tostring
  ! function, which is implemented below instead of lua_tolstring

  !> calls c_lua_tostring and saves the returned string to str
  !!
  !! @param str returned string
  !!
  subroutine lua_tostring(l, index, str)
    type(flu) :: l
    character(len=*), intent(out) :: str
    integer :: index, len
    type(c_ptr) :: ptr

    ptr = c_lua_tolstring(&
         l%lstate,&
         int(index,c_int),&
         int(len,c_int))

    call c_ptr_to_str(ptr, str, len)
  end subroutine lua_tostring


  subroutine lua_settop(l,stackIdx)
    type(flu) :: l
    integer :: stackIdx
    call c_lua_settop(l%lstate, int(stackIdx,c_int))
  end subroutine lua_settop


  function lua_isstring(l, index)
    type(flu) :: l
    integer :: index
    logical :: lua_isstring

    if(c_lua_isstring(l%lstate, int(index,c_int)) == 1) then
       lua_isstring = .true.
    else
       lua_isstring = .false.
    end if
  end function lua_isstring


  function lua_type(l,index)
    type(flu) :: l
    integer :: index, lua_type
    lua_type = c_lua_type(l%lstate, int(index,c_int))
  end function lua_type


  function lua_len(l,index)
    type(flu) :: l
    integer :: index, lua_len
    lua_len = c_lua_len(l%lstate, int(index,c_int))
  end function lua_len


  !> Tries to load a file and log any lua errors
  !!
  !! @param filename should be already trimmed
  !!
  !! @return .true. if file loads correctly, .false. otherwise
  !!
  function luaL_loadfile(l, filename)
    logical :: luaL_loadfile
    type(flu) :: l
    integer :: retval
    character(len=*) :: filename
    character(len=1000) :: msg

    retval = c_luaL_loadfilex_ptr(&
         l%lstate,&
         filename//c_null_char,&
         c_null_ptr)

    if( retval == LUA_OK ) then
       luaL_loadfile = .true.
       return
    else
       luaL_loadfile = .false.
       call lua_tostring(l,-1,msg)
       call l%log(FPDE_LOG_ERROR,"Unable to load file ["//filename//"]")
       call l%log(FPDE_LOG_ERROR,"Lua error:[" // trim(msg) // "]")
    end if
  end function luaL_loadfile


  subroutine lua_gettable(l,index)
    type(flu) :: l
    integer :: index
    call c_lua_gettable(l%lstate, int(index,c_int))
  end subroutine lua_gettable


  subroutine lua_settable(l, index)
    type(flu) :: l
    integer :: index
    call c_lua_settable(l%lstate,int(index,c_int))
  end subroutine lua_settable


  function lua_topointer(l,index)
    type(flu) :: l
    type(c_ptr) :: lua_topointer
    integer :: index
    lua_topointer = c_lua_topointer(l%lstate,int(index,c_int))
  end function lua_topointer


  subroutine lua_pushinteger(l,i)
    type(flu) :: l
    integer :: i
    call c_lua_pushinteger(l%lstate, int(i,c_int))
  end subroutine lua_pushinteger


  subroutine lua_pushnumber(l,val)
    type(flu) :: l
    real :: val
    call c_lua_pushnumber(l%lstate, val)
  end subroutine lua_pushnumber


  function lua_tointeger(l, idx)
    type(flu) :: l
    integer :: idx, lua_tointeger, isnum
    lua_tointeger = c_lua_tointegerx(l%lstate, int(idx,c_int),c_null_ptr)
  end function lua_tointeger


  subroutine lua_pushstring(l, str)
    type(flu) :: l
    character(len=*) :: str
    call c_lua_pushstring(l%lstate, str//c_null_char)
  end subroutine lua_pushstring


  function lua_gettop(l)
    type(flu) :: l
    integer :: lua_gettop
    lua_gettop = c_lua_gettop(l%lstate)
  end function lua_gettop


  subroutine luaL_openlibs(l)
    type(flu) :: l
    call c_luaL_openlibs(l%lstate)
  end subroutine luaL_openlibs


  subroutine lua_pushcclosure(l, fun, n)
    type(flu) :: l
    integer :: n
    procedure(c_lua_cfunction) :: fun

    call c_lua_pushcclosure(&
         l%lstate,&
         c_funloc(fun),&
         int(n,c_int))
  end subroutine lua_pushcclosure


  !> @param cptr has to be type(c_ptr) instead of e.g. class(*)
  !! because of possible rank mismatch when passing a fortran array
  subroutine lua_pushlightuserdata(l, cptr)
    type(flu) :: l
    type(c_ptr) :: cptr
    call c_lua_pushlightuserdata(l%lstate, cptr)
  end subroutine lua_pushlightuserdata


  function lua_newuserdata(l, size)
    type(flu) :: l
    integer :: size
    type(c_ptr) :: lua_newuserdata
    lua_newuserdata = c_lua_newuserdata(&
         l%lstate,&
         int(size,c_size_t))
  end function lua_newuserdata


  subroutine lua_setmetatable(l, index)
    type(flu) :: l
    integer :: index
    call c_lua_setmetatable(l%lstate, int(index,c_int))
  end subroutine lua_setmetatable


  subroutine lua_getmetatable(l, index)
    type(flu) :: l
    integer :: index
    call c_lua_getmetatable(l%lstate, int(index, c_int))
  end subroutine lua_getmetatable


  function luaL_newmetatable(l, name)
    type(flu) :: l
    character(len=*) :: name
    logical luaL_newmetatable
    if( c_luaL_newmetatable(l%lstate, name//c_null_char) == 0 ) then
       luaL_newmetatable = .false.
    else
       luaL_newmetatable = .true.
    end if
  end function luaL_newmetatable


  function luaL_checknumber(l, index)
    type(flu) :: l
    integer :: index
    real :: luaL_checknumber
    luaL_checknumber = c_luaL_checknumber(&
         l%lstate, int(index, c_int))
  end function luaL_checknumber


  function luaL_checkinteger(l, index)
    type(flu) :: l
    integer :: index
    integer :: luaL_checkinteger
    luaL_checkinteger = c_luaL_checkinteger(&
         l%lstate, int(index, c_int))
  end function luaL_checkinteger


  function luaL_checkudata(l, index, name)
    type(flu) :: l
    integer :: index
    character(len=*) :: name
    type(c_ptr) :: luaL_checkudata
    luaL_checkudata = c_luaL_checkudata(&
         l%lstate,&
         int(index, c_int),&
         trim(name)//c_null_char)
  end function luaL_checkudata


  subroutine lua_pop(l, n) bind(C,name="lua_pop")
    type(flu) :: l
    integer :: n
    call lua_settop(l, -n-1)
  end subroutine lua_pop


!   function lua_pcall(L,n,r,f)
!     type(c_ptr) :: L
!     integer(c_int) :: lua_pcall
!     integer(c_int) :: n, r, f

!     lua_pcall = lua_pcallk(L, n, r, f, 0_c_int, c_null_ptr)
!   end function lua_pcall

!   function luaL_loadfile(lstate, filename)
!     use iso_c_binding, only: c_ptr, c_char, c_int
!     integer(c_int) :: luaL_loadfile
!     type(c_ptr) :: lstate
!     character(len=*) :: filename

!     luaL_loadfile = luaL_loadfilex_ptr( lstate, trim(filename)//c_null_char, c_null_ptr )

!     if( luaL_loadfile /= 0 ) then
!        return
!     end if

!   end function luaL_loadfile

!   ! returns >0 in case of error
!   function luaL_dofile(lstate, filename)
!     integer(c_int) :: luaL_dofile
!     type(c_ptr) :: lstate
!     character(len=*) :: filename

!     luaL_dofile=luaL_loadfile(lstate,trim(filename))
!     if( luaL_dofile /=0 ) then
!        return
!     end if

!     luaL_dofile=lua_pcall(lstate,0_c_int,C_LUA_MULTRET,0_c_int)
!     if( luaL_dofile /= 0 ) then
!        return
!     end if

!   end function luaL_dofile

!   subroutine lua_tostring(lstate, index, str)
!     type(c_ptr) :: lstate
!     character(len=*), intent(out) :: str
!     integer(c_int) :: index, len
!     type(c_ptr) :: ptr
!     ! character(c_char), pointer :: c_str(:)

!     ptr = lua_tolstring(lstate,index,len)

!     ! call c_f_pointer(ptr, c_str, [len])
!     call c_ptr_to_str(ptr, str, len)

!   end subroutine lua_tostring

!   ! converts c_ptr (assuming it points to c_char) to character(len=*)

! !!!!!!!! Some high level lua calls

!   recursive function get_recursively(f, desc) result(r)
!     class(flu) :: f
!     character(len=*), intent(in) :: desc(:)
!     type(c_ptr) :: L
!     integer :: r
!     r = 0

!     L = f%lstate

!     call lua_pushstring(L,trim(desc(1))//c_null_char)
!     ! because we assume table is already on the top of the stack
!     ! index is -2
!     call lua_gettable(L,-2)
!     if( size(desc) > 1 ) then
!        if( lua_type(L,-1) == LUA_TTABLE ) then
!           r = get_recursively(f, desc(2:))
!        else if( lua_type(L,-1) == LUA_TNIL ) then
!           r = 1
!           call f%log( FPDE_LOG_ERROR, desc(1) // " is nil" )
!           return
!        else
!           r = 1
!           call f%log( FPDE_LOG_ERROR, desc(1) // " is not a table" )
!           return
!        end if
!     end if
!   end function get_recursively


!   !> pushes the value of the key f to the top of the stack
!   function push_by_key(f,id) result(r)
!     class(flu) :: f
!     character(len=*), intent(in) :: id(:)
!     integer :: t, r
!     type(c_ptr) :: L

!     r = 0
!     L = f%lstate

!     ! bring the root of the table to the stack
!     call lua_getglobal(L,trim(id(1))//c_null_char)
!     t = lua_type(L,-1)
!     ! call lua_tostring(L,-1,str)

!     if( size(id) > 1 ) then
!        if( t == LUA_TTABLE ) then
!           r = get_recursively(f,id(2:))
!        else
!           r = 1
!           call f%log( FPDE_LOG_ERROR, &
!                id(1) // " is not a table" )
!           return
!        end if
!     end if

!     ! one way or another we should end up with a string or table
!     if( (t /= LUA_TSTRING ) &
!          .and. (t /= LUA_TTABLE)&
!          .and. (t /= LUA_TNUMBER) ) then
!        r = 1
!        call f%log(FPDE_LOG_ERROR, &
!             "type of " // trim(f%array_to_key(id)) // " is not supported")
!        return
!     end if

!   end function push_by_key


!   ! initializes lua vm
!   subroutine init(f)
!     class(flu) :: f
!     f%lstate = luaL_newstate()
!     f%name = "flu"

!     if( c_associated( f%lstate ) ) then
!        call luaL_openlibs( f%lstate )
!        call f%log(FPDE_LOG_INFO, "Lua VM started")
!     else
!        call f%log(FPDE_LOG_ERROR, "unable to run Lua VM")
!     end if

!   end subroutine init

!   ! stops lua vm
!   subroutine free(f)
!     class(flu) :: f
!     call lua_close(f%lstate)
!   end subroutine free


!   ! loads and executes a file in lua vm
!   subroutine load_file(f,filename)
!     class(flu) :: f
!     character(len=*), intent(in) :: filename
!     ! @bug: len=100
!     character(len=100) :: out
!     integer :: status

!     status = luaL_dofile(f%lstate, filename)

!     if( status /= 0 ) then
!        call lua_tostring( f%lstate,-1,out )
!        call f%log(FPDE_LOG_ERROR, trim(out))
!        return
!     end if

!   end subroutine load_file


!   function get_character(f, id, out) result(r)
!     class(flu) :: f
!     character(len=*), intent(in) :: id(:)
!     character(len=*), intent(out) :: out
!     ! @bug: fixed length string
!     integer :: r

!     ! get the variable to the top of the stack
!     if( f%push_by_key(id) /= 0 ) then
!        r = 1
!        return
!     else if( lua_type(f%lstate,-1) == LUA_TSTRING ) then
!        call lua_tostring(f%lstate,-1,out)
!        r = 0
!        return
!     else
!        r = 1
!        call f%log(FPDE_LOG_ERROR,&
!             f%array_to_key(id)//" is not a string")
!        return
!     end if

!   end function get_character


!   function get_real(f, id, out) result(r)
!     class(flu) :: f
!     character(len=*), intent(in) :: id(:)
!     real, intent(out) :: out
!     ! @bug: fixed length string
!     character(len=100) :: str
!     integer :: r

!     ! get the variable to the top of the stack
!     if( f%push_by_key(id) /= 0 ) then
!        r = 1
!        return
!     else if( lua_type(f%lstate,-1) == LUA_TNUMBER ) then
!        call lua_tostring(f%lstate,-1,str)
!        read(str, *) out
!        r = 0
!        return
!     else
!        r = 1
!        call f%log(FPDE_LOG_ERROR,&
!             f%array_to_key(id)//" is not a number")
!        return
!     end if
!   end function get_real

!   ! writes length of the table designated by id to out
!   function get_len(f, id, out) result(r)
!     class(flu) :: f
!     character(len=*), intent(in) :: id(:)
!     integer, intent(out) :: out
!     ! @bug: fixed length string
!     character(len=100) :: str
!     integer :: r, i = 0, n = 0
!     type(c_ptr) :: L

!     L = f%lstate
!     ! get the variable to the top of the stack
!     if( f%push_by_key(id) /= 0 ) then
!        r = 1
!        return
!     else if( lua_type(L,-1) == LUA_TTABLE ) then
!        r = 0
!        ! determine the length of the array
!        out = lua_len(L, -1)
!     else
!        r = 1
!        call f%log(FPDE_LOG_WARNING,&
!             f%array_to_key(id)//" is not a table")
!        return
!     end if
!   end function get_len


!   function get_real_array(f, id, out) result(r)
!     class(flu) :: f
!     character(len=*), intent(in) :: id(:)
!     real, pointer, intent(out) :: out(:)
!     ! @bug: fixed length string
!     character(len=100) :: str
!     integer :: r, i = 0, n = 0
!     type(c_ptr) :: L

!     L = f%lstate
!     ! get the variable to the top of the stack
!     if( f%push_by_key(id) /= 0 ) then
!        r = 1
!        return
!     else if( lua_type(L,-1) == LUA_TTABLE ) then

!        ! determine the length of the array
!        n = lua_len(L, -1)
!        ! pop the length
!        call lua_pop(L,1)

!        ! read all the numbers
!        do i = 1, n
!           ! call lua_pushstring(L,trim(itoa(i))//c_null_char)
!           call lua_pushinteger(L,i)
!           call lua_gettable(L,-2)
!           if(lua_type(L,-1) == LUA_TNUMBER ) then
!              call lua_tostring(L,-1,str)
!              read(str, *) out(i)
!              ! pop the result, so the table is back at index -1
!              call lua_pop(L,1)
!           else
!              ! error, one of the elements is not a number
!              r = 1
!              call f%log(FPDE_LOG_ERROR,&
!                   trim(f%array_to_key(id))//"["//trim(itoa(i))//"] is not a number")
!              return
!           end if
!        end do
!        r = 0
!        return
!     else
!        r = 1
!        call f%log(FPDE_LOG_ERROR,&
!             f%array_to_key(id)//" is not a number")
!        return
!     end if
!   end function get_real_array


!   ! turns array of the form ["a", "b", "c"] to "a.b.c"
!   function array_to_key(f,key) result(r)
!     class(flu) :: f
!     character(len=*) :: key(:)
!     character(len=size(key)*(len(key)+len("."))) :: r

!     r = join(key, ".")
!   end function array_to_key

!   ! @todo extract to some utils library
!   function join(key, space) result(r)
!     character(len=*) :: key(:)
!     character(len=*) :: space
!     character(len=size(key)*(len(key)+len(space))) :: r
!     integer :: i

!     r = key(1)

!     do i = 2, size(key)
!        ! if( len(trim(key(1))) == 0) continue
!        r = trim(r)//space//key(i)
!     end do

!   end function join

!   ! @todo extract to some utils library
!   function itoa(i) result(r)
!     integer, intent(in) :: i
!     ! possibly @bug, constant length character on output
!     character(len=100) :: r

!     write(r,'(i99)') i
!     r=trim(adjustl(r))

!   end function itoa


end module flu_module
